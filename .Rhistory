#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
View(thisstate)
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>% filter(candidates != "Uncommitted") %>% filter(candidates != "NoPreference")
thisstate.spreaded <- spread(thisstate, candidates, votes)
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, B.Sanders, D.Trump, H.Clinton, J.Kasich, M.Rubio, T.Cruz) %>%
mutate(state = state)
thisstate.spreaded
parse_xml_states <- function(state) {
#state <- "NH"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, B.Sanders, D.Trump, H.Clinton, J.Kasich, M.Rubio, T.Cruz) %>%
mutate(state = state)
thisstate.spreaded
}
states <- c("NH", "SC", "NV", "AL", "AK", "AR", "GA", "MA", "MN", "OK", "TN", "TX", "VT", "VA", "KS", "KY", "LA", "ME", "HI", "ID", "MI", "MS", "DC", "FL", "IL", "MO", "NC", "OH", "AZ", "UT")
for (i in 2:length(states)) {
print(states[i])
this <- states[i]
assign(this, parse_xml_states(states[i]))
}
for (i in 1:length(states)) {
print(states[i])
this <- states[i]
assign(this, parse_xml_states(states[i]))
}
state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
View(thisstate)
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
View(thisstate.spreaded)
View(thisstate.spreaded)
e column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, !is.na(H.Clinton), !is.na(B.Sanders), D.Trump, T.Cruz, M.Rubio, J.Kasich) %>%
mutate(state = state)
?select
column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, matches("H.Clinton"), B.Sanders, D.Trump, T.Cruz, M.Rubio, J.Kasich) %>%
mutate(state = state)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, matches("H.Clinton"), matches("B.Sanders"), D.Trump, T.Cruz, M.Rubio, J.Kasich) %>%
mutate(state = state)
View(thisstate.spreaded)
parse_xml_states <- function(state) {
#state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip,
matches("H.Clinton"),
matches("B.Sanders"),
matches("D.Trump"),
matches("T.Cruz"),
matches("M.Rubio"),
matches("J.Kasich") %>%
mutate(state = state)
thisstate.spreaded
}
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip,
matches("H.Clinton"),
matches("B.Sanders"),
matches("D.Trump"),
matches("T.Cruz"),
matches("M.Rubio"),
matches("J.Kasich") %>%
mutate(state = state)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip,
matches("H.Clinton"),
matches("B.Sanders"),
matches("D.Trump"),
matches("T.Cruz"),
matches("M.Rubio"),
matches("J.Kasich") %>%
mutate(state = state)
parse_xml_states <- function(state) {
#state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip,
matches("H.Clinton"),
matches("B.Sanders"),
matches("D.Trump"),
matches("T.Cruz"),
matches("M.Rubio"),
matches("J.Kasich") %>% mutate(state = state)
thisstate.spreaded
}
parse_xml_states <- function(state) {
#state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, matches("H.Clinton"),
matches("B.Sanders"),
matches("D.Trump"),
matches("T.Cruz"),
matches("M.Rubio"),
matches("J.Kasich") %>% mutate(state = state)
thisstate.spreaded
}
parse_xml_states <- function(state) {
#state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, matches("H.Clinton"), matches("B.Sanders"), matches("D.Trump"), matches("T.Cruz"), matches("M.Rubio"), matches("J.Kasich") %>% mutate(state = state)
thisstate.spreaded
}
parse_xml_states <- function(state) {
#state <- "KY"
url <- paste(state, ".xml", sep = "")
doc <- xmlTreeParse(url, useInternal = TRUE)
thisstate <- data.frame()
ids <- unlist(doc["//article/@id"], use.names = FALSE)
#fips <- unlist(doc["//article/@data-fips"], use.names = FALSE)
for (i in 1:length(ids)) {
#i <- 2
id <- unlist(doc[paste("//article[", i, "]/@id")], use.names = FALSE)
fip <- unlist(doc[paste("//article[", i, "]/@data-fips")], use.names = FALSE)
candidates <- gsub("[[:space:]]", "", xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/th"), xmlValue))
pc <- xpathSApply(doc, paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-percentage']"), xmlValue)
votes <- as.numeric( # converts to numbers
gsub(",", "", # gsub used to remove commas
xpathSApply(doc,
paste("//article[", i, "]/div/div/div/table/tbody/tr/td[@class='results-popular']"),
xmlValue)))
thisstate <- rbind(thisstate,(cbind(fip, id, candidates, pc, votes)))
}
unique(thisstate$fip)
thisstate$pc <- NULL
thisstate$id <- NULL
# remove "Uncommitted" candidates to avoid duplicate pairs
thisstate <- thisstate %>%
filter(candidates != "Uncommitted") %>%
filter(candidates != "NoPreference") %>%
filter(candidates != "TotalWrite-ins")
thisstate.spreaded <- spread(thisstate, candidates, votes)
#Add State column
thisstate.spreaded <- thisstate.spreaded %>%
select(fip, matches("H.Clinton"), matches("B.Sanders"), matches("D.Trump"), matches("T.Cruz"), matches("M.Rubio"), matches("J.Kasich")) %>%
mutate(state = state)
thisstate.spreaded
}
IOWA missing from Politico data
states <- c("NH", "SC", "NV", "AL", "AK", "AR", "GA", "MA", "MN", "OK", "TN", "TX", "VT", "VA", "KS", "KY", "LA", "ME", "HI", "ID", "MI", "MS", "DC", "FL", "IL", "MO", "NC", "OH", "AZ", "UT")
for (i in 1:length(states)) {
print(states[i])
this <- states[i]
assign(this, parse_xml_states(states[i]))
}
View(ME)
View(KY)
View(DC)
View(AK)
View(KS)
View(MN)
st <- rbind(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
st <- merge(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
st <- rbind(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
?bind_rows
st <- bind_rows(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
View(st)
write.csv(st, "local.csv")
write.csv(st, "local.csv", row.names = FALSE)
st.cl <- st %>% select(fip, as.numeric(H.Clinton))
View(st.cl)
st.cl <- st %>% select(fip, as.numeric(H.Clinton))
# Export data to csv file
write.csv(st.cl, "local.cl.csv", row.names = FALSE)
vars <- names(st)
vars
vars <- names(st[2:7])
vars
st$max <- apply(st[2:7], 1, which.max)
View(st)
dems <- names(st[2:3])
dems
st$maxdems <- apply(st[2:3], 1, which.max)
View(st)
reps <- names(st[4:7])
reps
st$maxreps <- apply(st[4:7], 1, which.max)
View(st)
for (j in 1:length(st$fip)) {
# get the label of max value (the candidate with the maximum of votes)
st$winnerdem[j] <- as.character(st[j,st$maxdems[j]])
}
st <- st %>% mutate(indexdems=maxdems+1)
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
View(st)
st <- st %>% mutate(indexdems=maxdems+1)
View(st)
for (j in 1:length(st$fip)) {
# get the label of max value (the candidate with the maximum of votes)
st$winnerdem[j] <- as.character(st[j,st$indexdems[j]])
}
View(st)
for (j in 1:length(st$fip)) {
# get the label of max value (the candidate with the maximum of votes)
st$winnerdem_votes[j] <- as.numeric(st[j,st$indexdems[j]])
st$winnerdem <- as.character(dems[maxdems])
}
for (j in 1:length(st$fip)) {
# get the label of max value (the candidate with the maximum of votes)
st$winnerdem_votes[j] <- as.numeric(st[j,st$indexdems[j]])
st$winnerdem <- as.character(dems[st$maxdems])
}
for (j in 1:length(st$fip)) {
# get the label of max value (the candidate with the maximum of votes)
st$winnerdem_votes[j] <- st[j,st$indexdems[j]]
st$winnerdem <- as.character(dems[st$maxdems])
}
View(st)
# Bind States's data
# bind_rows (from dplyr) allows to rbind datafames with uneven number of columns
st <- bind_rows(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
#st.cl <- st %>% select(fip, as.numeric(H.Clinton))
#
View(st)
dems <- names(st[2:3])
reps <- names(st[4:7])
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
st$maxreps <- apply(st[4:7], 1, which.max)
st <- st %>% mutate(indexdems = maxdems + 1, indexreps = maxreps + 3) # Column index of the label of the max value
dems <- names(st[2:3])
reps <- names(st[4:7])
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
st$maxreps <- as.numeric(apply(st[4:7], 1, which.max))
st <- st %>% mutate(indexdems = maxdems + 1, indexreps = maxreps + 3) # Column index of the label of the max value
View(st)
for (j in 1:length(st$fip)) {
# get the max value (the number of votes obtained by the winner)
st$winnerdem_votes[j] <- st[j,st$indexdems[j]]
st$winnerrep_votes[j] <- st[j,st$indexreps[j]]
# get the name of the winner
st$winnerdem <- as.character(dems[st$maxdems])
st$winnerrep <- as.character(reps[st$maxreps])
}
View(st)
st <- st %>% filter(-maxdems)
st <- st %>% filter-(maxdems)
st <- st %>% select(-maxdems)
View(st)
st <- st %>% select(-maxdems, -maxreps, -indexdems, -indexreps)
# Bind States's data
# bind_rows (from dplyr) allows to rbind datafames with uneven number of columns
st <- bind_rows(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
#st.cl <- st %>% select(fip, as.numeric(H.Clinton))
# find the winner
## for each row, find the index of the column with max value
### for the dems
dems <- names(st[2:3])
reps <- names(st[4:7])
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
st$maxreps <- as.numeric(apply(st[4:7], 1, which.max))
st <- st %>% mutate(indexdems = maxdems + 1, indexreps = maxreps + 3) # Column index of the label of the max value
for (j in 1:length(st$fip)) {
# get the max value (the number of votes obtained by the winner)
st$winnerdem_votes[j] <- st[j,st$indexdems[j]]
st$winnerrep_votes[j] <- st[j,st$indexreps[j]]
# get the name of the winner
st$winnerdem <- as.character(dems[st$maxdems])
st$winnerrep <- as.character(reps[st$maxreps])
}
st <- st %>% select(-maxdems, -maxreps, -indexdems, -indexreps)
View(st)
# Export data to csv file
write.csv(st, "local.csv", row.names = FALSE)
View(st)
# Export data to csv file
write.csv(st, "local.csv", row.names = FALSE)
st <- st %>% as.data.frame(select(-maxdems, -maxreps, -indexdems, -indexreps))
# Export data to csv file
write.csv(st, "local.csv", row.names = FALSE)
View(st)
# Bind States's data
# bind_rows (from dplyr) allows to rbind datafames with uneven number of columns
st <- bind_rows(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
#st.cl <- st %>% select(fip, as.numeric(H.Clinton))
# find the winner
## for each row, find the index of the column with max value
### for the dems
dems <- names(st[2:3])
reps <- names(st[4:7])
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
st$maxreps <- as.numeric(apply(st[4:7], 1, which.max))
st <- st %>% mutate(indexdems = maxdems + 1, indexreps = maxreps + 3) # Column index of the label of the max value
for (j in 1:length(st$fip)) {
# get the max value (the number of votes obtained by the winner)
st$winnerdem_votes[j] <- st[j,st$indexdems[j]]
st$winnerrep_votes[j] <- st[j,st$indexreps[j]]
# get the name of the winner
st$winnerdem <- as.character(dems[st$maxdems])
st$winnerrep <- as.character(reps[st$maxreps])
}
# Export data to csv file
write.csv(st, "local.csv", row.names = FALSE)
# housekeeping (remove useless columns)
st <- st %>% select(-maxdems, -maxreps, -indexdems, -indexreps)
st <- as.data.frame(st)
str(st)
# Bind States's data
# bind_rows (from dplyr) allows to rbind datafames with uneven number of columns
st <- bind_rows(NH, SC, NV, AL, AK, AR, GA, MA, MN, OK, TN, TX, VT, VA, KS, KY, LA, ME, HI, ID, MI, MS, DC, FL, IL, MO, NC, OH, AZ, UT)
#st.cl <- st %>% select(fip, as.numeric(H.Clinton))
# find the winner
## for each row, find the index of the column with max value
### for the dems
dems <- names(st[2:3])
reps <- names(st[4:7])
st$maxdems <- as.numeric(apply(st[2:3], 1, which.max))
st$maxreps <- as.numeric(apply(st[4:7], 1, which.max))
st <- st %>% mutate(indexdems = maxdems + 1, indexreps = maxreps + 3) # Column index of the label of the max value
for (j in 1:length(st$fip)) {
# get the max value (the number of votes obtained by the winner)
st$winnerdem_votes[j] <- as.numeric(st[j,st$indexdems[j]])
st$winnerrep_votes[j] <- as.numeric(st[j,st$indexreps[j]])
# get the name of the winner
st$winnerdem <- as.character(dems[st$maxdems])
st$winnerrep <- as.character(reps[st$maxreps])
}
# housekeeping (remove useless columns)
st <- st %>% select(-maxdems, -maxreps, -indexdems, -indexreps)
str(st)
# Export data to csv file
write.csv(st, "local.csv", row.names = FALSE)
View(st)
